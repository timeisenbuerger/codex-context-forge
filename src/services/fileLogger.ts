import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';

export interface FileOperation {
  type: 'created' | 'updated' | 'skipped' | 'failed';
  filePath: string;
  relativePath: string;
  description: string;
  timestamp: Date;
  error?: string;
}

export class FileLogger {
  private operations: FileOperation[] = [];
  private rootPath: string;
  private logFilePath: string;

  constructor(rootPath: string) {
    this.rootPath = rootPath;
    this.logFilePath = path.join(rootPath, 'codex-context-forge.log');
  }

  logOperation(operation: Omit<FileOperation, 'timestamp' | 'relativePath'>) {
    const relativePath = path.relative(this.rootPath, operation.filePath);
    const fullOperation: FileOperation = {
      ...operation,
      relativePath,
      timestamp: new Date(),
    };

    this.operations.push(fullOperation);

    // Log to console with actual file path
    const symbol = this.getSymbol(operation.type);
    const color = this.getColor(operation.type);
    const message = `${symbol} ${color(relativePath)}`;

    console.log(message);

    if (operation.error) {
      console.log(chalk.red(`   Error: ${operation.error}`));
    }
  }

  private getSymbol(type: FileOperation['type']): string {
    switch (type) {
      case 'created':
        return '✔';
      case 'updated':
        return '↻';
      case 'skipped':
        return '⊝';
      case 'failed':
        return '✗';
      default:
        return '•';
    }
  }

  private getColor(type: FileOperation['type']): (str: string) => string {
    switch (type) {
      case 'created':
        return chalk.green;
      case 'updated':
        return chalk.blue;
      case 'skipped':
        return chalk.yellow;
      case 'failed':
        return chalk.red;
      default:
        return chalk.gray;
    }
  }

  async writeLogFile(): Promise<void> {
    const logContent = this.generateLogContent();
    await fs.writeFile(this.logFilePath, logContent, 'utf-8');
  }

  private generateLogContent(): string {
    const timestamp = new Date().toISOString();
    const summary = this.generateSummary();

    let content = `# Codex Context Forge Generation Log
Generated: ${timestamp}

## Summary
${summary}

## File Operations
`;

    for (const operation of this.operations) {
      content += `
### ${operation.type.toUpperCase()}: ${operation.relativePath}
- **Full Path**: ${operation.filePath}
- **Description**: ${operation.description}
- **Timestamp**: ${operation.timestamp.toISOString()}`;

      if (operation.error) {
        content += `
- **Error**: ${operation.error}`;
      }
    }

    content += `

## Directory Structure Created
${this.generateDirectoryStructure()}

## Next Steps
1. Review the generated files above
2. Customize the configuration files as needed
3. Add project-specific documentation
4. Test the IDE integration
5. Begin development with enhanced AI assistance

---
Generated by Codex Context Forge v${this.getVersion()}
`;

    return content;
  }

  private generateSummary(): string {
    const counts = this.operations.reduce(
      (acc, op) => {
        acc[op.type] = (acc[op.type] || 0) + 1;
        return acc;
      },
      {} as Record<string, number>
    );

    const total = this.operations.length;
    const success = (counts.created || 0) + (counts.updated || 0);
    const failed = counts.failed || 0;
    const skipped = counts.skipped || 0;

    return `- **Total Operations**: ${total}
- **Successfully Created/Updated**: ${success}
- **Failed**: ${failed}
- **Skipped**: ${skipped}
- **Success Rate**: ${total > 0 ? Math.round((success / total) * 100) : 0}%`;
  }

  private generateDirectoryStructure(): string {
    const dirs = new Set<string>();

    for (const operation of this.operations) {
      if (operation.type === 'created' || operation.type === 'updated') {
        const dir = path.dirname(operation.relativePath);
        if (dir !== '.') {
          dirs.add(dir);
        }
      }
    }

    const sortedDirs = Array.from(dirs).sort();
    if (sortedDirs.length === 0) {
      return '- No subdirectories created';
    }

    return sortedDirs.map((dir) => `- ${dir}/`).join('\n');
  }

  private getVersion(): string {
    try {
      // Try to read package.json version
      const packagePath = path.join(__dirname, '../../package.json');
      const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf-8'));
      return packageJson.version || 'unknown';
    } catch {
      return 'unknown';
    }
  }

  getOperations(): FileOperation[] {
    return [...this.operations];
  }

  getSummaryStats() {
    const counts = this.operations.reduce(
      (acc, op) => {
        acc[op.type] = (acc[op.type] || 0) + 1;
        return acc;
      },
      {} as Record<string, number>
    );

    return {
      total: this.operations.length,
      created: counts.created || 0,
      updated: counts.updated || 0,
      skipped: counts.skipped || 0,
      failed: counts.failed || 0,
    };
  }
}
